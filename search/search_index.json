{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Azure Firewall Egress Controller provides stricter policy enforcement at the Azure Firewall that is application aware in an automated fashion with real time updates as the AKS cluster grows and shrinks. AKS (Azure Kubernetes Service) workloads are secured using Azure Firewall as the egress firewall. The Egress Controller runs in its own pod on the customer\u2019s AKS. AFEC monitors a subset of Kubernetes Resources for changes. The state of the AKS cluster is translated to Azure Firewall specific configuration and applied to the Azure Resource Manager (ARM) . Existing architecture secures the egress traffic for the entire cluster. Contributing This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com . When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Trademarks This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft's Trademark & Brand Guidelines . Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party's policies.","title":"Introduction"},{"location":"#introduction","text":"Azure Firewall Egress Controller provides stricter policy enforcement at the Azure Firewall that is application aware in an automated fashion with real time updates as the AKS cluster grows and shrinks. AKS (Azure Kubernetes Service) workloads are secured using Azure Firewall as the egress firewall. The Egress Controller runs in its own pod on the customer\u2019s AKS. AFEC monitors a subset of Kubernetes Resources for changes. The state of the AKS cluster is translated to Azure Firewall specific configuration and applied to the Azure Resource Manager (ARM) . Existing architecture secures the egress traffic for the entire cluster.","title":"Introduction"},{"location":"#contributing","text":"This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.opensource.microsoft.com . When you submit a pull request, a CLA bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., status check, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Contributing"},{"location":"#trademarks","text":"This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft's Trademark & Brand Guidelines . Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party's policies.","title":"Trademarks"},{"location":"developers/build/","text":"Azure Firewall Controller Deployment Workflow The Azure Firewall Controller is a pod within your Kubernetes cluster which monitors a subset of Kubernetes Resources and translates them to Azure Firewall specific configuration and applies to the Azure Resource Manager (ARM) . Outline: Prerequisites Azure Resource Manager Authentication (ARM) Option 1: Using a Service Principal Install Azure Firewall Controller using Helm Prerequisites This documents assumes you already have the following tools and infrastructure installed: - Azure Firewall as the next hop to the AKS cluster. Please follow this documentation for the setup. Make sure to add additional rules in the firewall to allow node <-> api-server communication and also to allow access to images in the Microsoft Container Registry(MCR). - Create an Active Directory Service Principal. - If you are using Azure Cloud Shell it has all the tools already installed. Launch your shell from shell.azure.com or by clicking the link: Launch Azure Cloud Shell . If you choose to use another environment, please ensure the following command line tools are installed: 1. az - Azure CLI: installation instructions 2. kubectl - Kubernetes command-line tool: installation instructions 3. helm (version 3.7 or later) - Kubernetes package manager: installation instructions Setup Kubernetes Credentials For the following steps we need setup kubectl command, which we will use to connect to our new Kubernetes cluster. We will use az CLI to obtain credentials for Kubernetes. Get credentials for your newly deployed AKS ( read more ): az aks get-credentials --resource-group aksClusterResourceGroupName --name aksClusterName Deploying cert-manager Validation Webhooks are implemented for the CRD. In order for the API server to communicate with the webhook component, the webhook requires a TLS certificate that the apiserver is configured to trust. We are using cert-manager for provisioning the certificates for the webhook. cert-manager Installation ( read more ): kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.yaml Azure Resource Manager Authentication AFEC communicates with the Kubernetes API server and the Azure Resource Manager. It requires an identity to access these APIs. Using a Service Principal AFEC access to ARM can be possible by creating service principal. Follow the steps below to create an Azure Active Directory (AAD) service principal object. Create an Active Directory Service Principal and make sure the created service principal has contributor access to the Azure Firewall. az ad sp create-for-rbac --role Contributor --scopes /subscriptions/policySubscriptionId Please record the appId ( <azureClientId> ), password( <azureClientSecret> ), and tenant( <azureTenantId> ) values - these will be used in the following steps to authenticate to azure. Install Azure Firewall Controller as a Helm Chart Helm is a package manager for Kubernetes. This document uses Helm version 3.7 or later. We will leverage it to install the azure-firewall-egress-controller package. Use Cloud Shell to install install the AFEC Helm package: Install Helm chart helm install [RELEASE_NAME] oci://mcr.microsoft.com/azfw/helmchart/afec --version 0.1.0 \\ --debug \\ --set fw.policyResourceID=<fwPolicyResourceID> \\ --set fw.policyResourceGroup=<fwPolicyResourceGroup> \\ --set fw.policySubscriptionId=<fwPolicySubscriptionId> \\ --set fw.policyName=<fwPolicyName> \\ --set fw.policyRuleCollectionGroup=<fwPolicyRuleCollectionGroup> \\ --set fw.policyRuleCollectionGroupPriority=<fwPolicyRuleCollectionGroupPriority> \\ --set auth.tenantId=<azureTenantId> \\ --set auth.clientId=<azureClientId> \\ --set auth.clientSecret=<azureClientSecret> [RELEASE_NAME] can be any chosen name. <azureTenantId> and <azureClientId> and <azureClientSecret> are values that were created in the previous section. If a Firewall Policy Resource Id is provided, individual fields of fwpolicySubscriptionId, fwpolicyResourceGroup and fwPolicyName will be ignored Parameters <fwpolicyResourceId> : ID of the Firewall Policy. <fwpolicyResourceGroup> : Name of the Azure Resource group in which Azure Firewall Policy was created. <fwpolicySubscriptionId> : The Azure Subscription ID in which Azure Firewall Policy resides. Example: a123b234-a3b4-557d-b2df-a0bc12de1234 <fwPolicyName> : Name of the Azure Firewall Policy that is attached to the firewall. <fwPolicyRuleCollectionGroup> : The Rule Collection Group in the Firewall Policy dedicated to the Egress Controller. <fwPolicyRuleCollectionGroupPriority> : The Priority of the Rule Collection Group in the Firewall Policy dedicated to the Egress Controller. <azureTenantId> : The tenant ID of the Identity. <azureClientId> : The client ID of the Identity. <azureClientSecret> : The client Secret of the Identity. To upgrade the chart helm upgrade [RELEASE_NAME] oci://mcr.microsoft.com/azfw/helmchart/afec --version [LATEST_VERSION] \\ --debug \\ --set fw.policyResourceID=<fwPolicyResourceID> \\ --set fw.policyResourceGroup=<fwPolicyResourceGroup> \\ --set fw.policySubscriptionId=<fwPolicySubscriptionId> \\ --set fw.policyName=<fwPolicyName> \\ --set fw.policyRuleCollectionGroup=<fwPolicyRuleCollectionGroup> \\ --set fw.policyRuleCollectionGroupPriority=<fwPolicyRuleCollectionGroupPriority> \\ --set auth.tenantId=<azureTenantId> \\ --set auth.clientId=<azureClientId> \\ --set auth.clientSecret=<azureClientSecret> [LATEST_VERSION] is the specific version to which you intend to upgrade your Helm release. Verify the afc controller pods are ready. kubectl get pods -n aks-egress-system Check the log of the newly created pod to verify if it started properly. kubectl logs <pod_name> -c manager -n aks-egress-system","title":"Azure Firewall Controller Deployment Workflow"},{"location":"developers/build/#azure-firewall-controller-deployment-workflow","text":"The Azure Firewall Controller is a pod within your Kubernetes cluster which monitors a subset of Kubernetes Resources and translates them to Azure Firewall specific configuration and applies to the Azure Resource Manager (ARM) .","title":"Azure Firewall Controller Deployment Workflow"},{"location":"developers/build/#outline","text":"Prerequisites Azure Resource Manager Authentication (ARM) Option 1: Using a Service Principal Install Azure Firewall Controller using Helm","title":"Outline:"},{"location":"developers/build/#prerequisites","text":"This documents assumes you already have the following tools and infrastructure installed: - Azure Firewall as the next hop to the AKS cluster. Please follow this documentation for the setup. Make sure to add additional rules in the firewall to allow node <-> api-server communication and also to allow access to images in the Microsoft Container Registry(MCR). - Create an Active Directory Service Principal. - If you are using Azure Cloud Shell it has all the tools already installed. Launch your shell from shell.azure.com or by clicking the link: Launch Azure Cloud Shell . If you choose to use another environment, please ensure the following command line tools are installed: 1. az - Azure CLI: installation instructions 2. kubectl - Kubernetes command-line tool: installation instructions 3. helm (version 3.7 or later) - Kubernetes package manager: installation instructions","title":"Prerequisites"},{"location":"developers/build/#setup-kubernetes-credentials","text":"For the following steps we need setup kubectl command, which we will use to connect to our new Kubernetes cluster. We will use az CLI to obtain credentials for Kubernetes. Get credentials for your newly deployed AKS ( read more ): az aks get-credentials --resource-group aksClusterResourceGroupName --name aksClusterName","title":"Setup Kubernetes Credentials"},{"location":"developers/build/#deploying-cert-manager","text":"Validation Webhooks are implemented for the CRD. In order for the API server to communicate with the webhook component, the webhook requires a TLS certificate that the apiserver is configured to trust. We are using cert-manager for provisioning the certificates for the webhook. cert-manager Installation ( read more ): kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.yaml","title":"Deploying cert-manager"},{"location":"developers/build/#azure-resource-manager-authentication","text":"AFEC communicates with the Kubernetes API server and the Azure Resource Manager. It requires an identity to access these APIs.","title":"Azure Resource Manager Authentication"},{"location":"developers/build/#using-a-service-principal","text":"AFEC access to ARM can be possible by creating service principal. Follow the steps below to create an Azure Active Directory (AAD) service principal object. Create an Active Directory Service Principal and make sure the created service principal has contributor access to the Azure Firewall. az ad sp create-for-rbac --role Contributor --scopes /subscriptions/policySubscriptionId Please record the appId ( <azureClientId> ), password( <azureClientSecret> ), and tenant( <azureTenantId> ) values - these will be used in the following steps to authenticate to azure.","title":"Using a Service Principal"},{"location":"developers/build/#install-azure-firewall-controller-as-a-helm-chart","text":"Helm is a package manager for Kubernetes. This document uses Helm version 3.7 or later. We will leverage it to install the azure-firewall-egress-controller package. Use Cloud Shell to install install the AFEC Helm package: Install Helm chart helm install [RELEASE_NAME] oci://mcr.microsoft.com/azfw/helmchart/afec --version 0.1.0 \\ --debug \\ --set fw.policyResourceID=<fwPolicyResourceID> \\ --set fw.policyResourceGroup=<fwPolicyResourceGroup> \\ --set fw.policySubscriptionId=<fwPolicySubscriptionId> \\ --set fw.policyName=<fwPolicyName> \\ --set fw.policyRuleCollectionGroup=<fwPolicyRuleCollectionGroup> \\ --set fw.policyRuleCollectionGroupPriority=<fwPolicyRuleCollectionGroupPriority> \\ --set auth.tenantId=<azureTenantId> \\ --set auth.clientId=<azureClientId> \\ --set auth.clientSecret=<azureClientSecret> [RELEASE_NAME] can be any chosen name. <azureTenantId> and <azureClientId> and <azureClientSecret> are values that were created in the previous section. If a Firewall Policy Resource Id is provided, individual fields of fwpolicySubscriptionId, fwpolicyResourceGroup and fwPolicyName will be ignored","title":"Install Azure Firewall Controller as a Helm Chart"},{"location":"developers/build/#parameters","text":"<fwpolicyResourceId> : ID of the Firewall Policy. <fwpolicyResourceGroup> : Name of the Azure Resource group in which Azure Firewall Policy was created. <fwpolicySubscriptionId> : The Azure Subscription ID in which Azure Firewall Policy resides. Example: a123b234-a3b4-557d-b2df-a0bc12de1234 <fwPolicyName> : Name of the Azure Firewall Policy that is attached to the firewall. <fwPolicyRuleCollectionGroup> : The Rule Collection Group in the Firewall Policy dedicated to the Egress Controller. <fwPolicyRuleCollectionGroupPriority> : The Priority of the Rule Collection Group in the Firewall Policy dedicated to the Egress Controller. <azureTenantId> : The tenant ID of the Identity. <azureClientId> : The client ID of the Identity. <azureClientSecret> : The client Secret of the Identity. To upgrade the chart helm upgrade [RELEASE_NAME] oci://mcr.microsoft.com/azfw/helmchart/afec --version [LATEST_VERSION] \\ --debug \\ --set fw.policyResourceID=<fwPolicyResourceID> \\ --set fw.policyResourceGroup=<fwPolicyResourceGroup> \\ --set fw.policySubscriptionId=<fwPolicySubscriptionId> \\ --set fw.policyName=<fwPolicyName> \\ --set fw.policyRuleCollectionGroup=<fwPolicyRuleCollectionGroup> \\ --set fw.policyRuleCollectionGroupPriority=<fwPolicyRuleCollectionGroupPriority> \\ --set auth.tenantId=<azureTenantId> \\ --set auth.clientId=<azureClientId> \\ --set auth.clientSecret=<azureClientSecret> [LATEST_VERSION] is the specific version to which you intend to upgrade your Helm release. Verify the afc controller pods are ready. kubectl get pods -n aks-egress-system Check the log of the newly created pod to verify if it started properly. kubectl logs <pod_name> -c manager -n aks-egress-system","title":"Parameters"},{"location":"developers/contribute/","text":"Contribution Guidelines This is a Golang project. You can find the build instructions of the project in the Developer Guide . This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com . When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Contribution Guidelines"},{"location":"developers/contribute/#contribution-guidelines","text":"This is a Golang project. You can find the build instructions of the project in the Developer Guide . This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com . When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Contribution Guidelines"},{"location":"developers/crds/","text":"Custom Resource Definition (CRD) A\u202fresource\u202fis an endpoint in the\u202fKubernetes API\u202fthat stores a collection of\u202fAPI objects a certain kind; for example, the built-in\u202fpods\u202fresource contains a collection of Pod objects. A\u202fcustom resource\u202fis an extension of the Kubernetes API that is not necessarily available in a default Kubernetes installation. It represents a customization of a particular Kubernetes installation. The AzureFirewallRules Resource: The AzureFirewallRules format which is a cluster-scoped CustomResourceDefinition allows us define configuration for the egress traffic and deploy it to the cluster. The raw specification of the resource in Go looks like this: // AzureFirewallRules is the Schema for the azureFirewallRules API type AzureFirewallRules struct { metav1.TypeMeta ` json: \",inline\" ` metav1.ObjectMeta ` json: \"metadata,omitempty\" ` // AzureFirewallRulesSpec defines the desired state of azureFirewallRules Spec AzureFirewallRulesSpec ` json: \"spec,omitempty\" ` // AzureFirewallRulesStatus defines the observed state of azureFirewallRules Status AzureFirewallRulesStatus ` json: \"status,omitempty\" ` } An example AzureFirewallRules might look like this: apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"test-egress-rule-1\" nodeSelector: - app: \"nginx0\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network\" priority: 110 destinationFqdns: [ \"*\" ] destinationPorts: [ \"*\" ] protocol : [ \"TCP\" , \"UDP\" ] action : \"Allow\" ruleType: \"Network\" - ruleName: \"rule2\" ruleCollectionName: \"aks-fw-ng\" priority: 200 targetFqdns: [ \"*.yahoo.com\" ] protocol : [ \"HTTP:80\" ] action : \"Deny\" ruleType: \"Application\" - name: \"test-egress-rule-2\" nodeSelector: - nodepool1: \"set1\" - nodepool2: \"set1\" rules: - ruleName: \"rule3\" ruleCollectionName: \"aks-fw-ng\" priority: 200 targetFqdns: [ \"*.yahoo.com\" ] protocol : [ \"HTTP:80\" ] action : \"Deny\" ruleType: \"Application\" Mandatory Fields : As with all other Kubernetes config, a AzureFirewallRules needs apiVersion , Kind , and metadata fields. metadata field includes the name of the policy and the set of labels to identify the resources in Kubernetes. spec : Egressrules spec has all the information needed to define rules on Azure Firewall. egressRules : egressRules field allows us to define list of egress rules on the nodes using the labels asigned to them. This field will allow us to have multiple rules on different node selectors. The example shown above defines two egressRules test-egress-rule-1 and test-egress-rule-2 . And the rules defined in test-egress-rule-1 will be applied to nodes that match label \"app=nginx0\" and the rules in `test-egress-rule-2 will be applied to nodes with label \"nodepool1=set1\" and \"nodepool2=set1\". nodeSelector : nodeSelector is a list of node labels to which the rules should apply. In the above example, we defined the nodeSelector with the label \"app=nginx0\" All the nodes that are grouped using this nodeSelector label will adhere to those rules. rules : rules field allows us define list of azure firewall rules that the nodes grouped using this nodeSelector label should follow. - ruleName , ruleCollectionName , priority , protocol , action , ruleType are the mandatory fields in rules section. - Two rule types are supported in the AzureFirewallRules - Application and Network . Field Description ruleName Name of the rule ruleCollectionName Rule Collection to which the rule should belong. priority The priority value of the rule collection, determines order the rule collections are processed. action Rule Collection action. Applies to all the rules in the rule collection. Supported Values: \"Allow\" or \"Deny\" ruleType Supported rule types: \"Application\" or \"Network\" protocol Defines the protocol that should be used to filter the traffic. Examples: Application rule: [\"https:80\",\"http:443\"] Network rule: [\"TCP\"], [\"TCP\",\"UDP\"], [\"ICMP\"], [\"ANY\"] targetFqdns targetUrls Supported destination types for a Application rule. Specifies the list of destination fqdns or urls that should be used to filter the traffic. destinationAddresses destinationFqdns Supported destination types for a Network rule. Specifies the list of destination addresses or fqdns that should be used to filter the trafficrule. destinationPorts List of destination ports that should be used to filter the traffic in a network rule. Examples of Application Rule Type: The following example allows the egress traffic from nodes with label \"app=service\" to *.google.com. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"Allow-google\" nodeSelector: - app: \"service\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-allow\" priority: 210 targetFqdns: [ \"*.google.com\" ] protocol : [ \"HTTP:80\" ] action : \"Allow\" ruleType: \"Application\" Examples of Network Rule Type: 1. The following example allows egress traffic from nodes with label \"role=db\" to destination addresses \"10.0.0.1\" and \"10.0.0.2\" on any port using TCP. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"Allow-addresses\" nodeSelector: - role: \"db\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network\" priority: 110 destinationAddresses: [ \"10.0.0.1\" , \"10.0.0.2\" ] destinationPorts: [ \"*\" ] protocol : [ \"TCP\" ] action : \"Allow\" ruleType: \"Network\" We can have rules to allow/deny traffic to any destination. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"Allow-web\" nodeSelector: - app: \"service\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network\" priority: 110 destinationAddresses: [ \"*\" ] destinationPorts: [ \"80\" , \"443\" ] protocol : [ \"TCP\" ] action : \"Allow\" ruleType: \"Network\" We can have combination of network and application rules in just one resource. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"comb-network-application-rules\" nodeSelector: - app: \"nginx0\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network-deny\" priority: 100 destinationFqdns: [ \"*\" ] destinationPorts: [ \"*\" ] protocol : [ \"TCP\" , \"UDP\" ] action : \"Deny\" ruleType: \"Network\" - ruleName: \"rule2\" ruleCollectionName: \"aks-fw-ng\" priority: 200 targetFqdns: [ \"*.yahoo.com\" ] protocol : [ \"HTTP:80\" ] action : \"Deny\" ruleType: \"Application\"","title":"Crds"},{"location":"developers/crds/#custom-resource-definition-crd","text":"A\u202fresource\u202fis an endpoint in the\u202fKubernetes API\u202fthat stores a collection of\u202fAPI objects a certain kind; for example, the built-in\u202fpods\u202fresource contains a collection of Pod objects. A\u202fcustom resource\u202fis an extension of the Kubernetes API that is not necessarily available in a default Kubernetes installation. It represents a customization of a particular Kubernetes installation.","title":"Custom Resource Definition (CRD)"},{"location":"developers/crds/#the-azurefirewallrules-resource","text":"The AzureFirewallRules format which is a cluster-scoped CustomResourceDefinition allows us define configuration for the egress traffic and deploy it to the cluster.","title":"The AzureFirewallRules Resource:"},{"location":"developers/crds/#the-raw-specification-of-the-resource-in-go-looks-like-this","text":"// AzureFirewallRules is the Schema for the azureFirewallRules API type AzureFirewallRules struct { metav1.TypeMeta ` json: \",inline\" ` metav1.ObjectMeta ` json: \"metadata,omitempty\" ` // AzureFirewallRulesSpec defines the desired state of azureFirewallRules Spec AzureFirewallRulesSpec ` json: \"spec,omitempty\" ` // AzureFirewallRulesStatus defines the observed state of azureFirewallRules Status AzureFirewallRulesStatus ` json: \"status,omitempty\" ` }","title":"The raw specification of the resource in Go looks like this:"},{"location":"developers/crds/#an-example-azurefirewallrules-might-look-like-this","text":"apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"test-egress-rule-1\" nodeSelector: - app: \"nginx0\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network\" priority: 110 destinationFqdns: [ \"*\" ] destinationPorts: [ \"*\" ] protocol : [ \"TCP\" , \"UDP\" ] action : \"Allow\" ruleType: \"Network\" - ruleName: \"rule2\" ruleCollectionName: \"aks-fw-ng\" priority: 200 targetFqdns: [ \"*.yahoo.com\" ] protocol : [ \"HTTP:80\" ] action : \"Deny\" ruleType: \"Application\" - name: \"test-egress-rule-2\" nodeSelector: - nodepool1: \"set1\" - nodepool2: \"set1\" rules: - ruleName: \"rule3\" ruleCollectionName: \"aks-fw-ng\" priority: 200 targetFqdns: [ \"*.yahoo.com\" ] protocol : [ \"HTTP:80\" ] action : \"Deny\" ruleType: \"Application\" Mandatory Fields : As with all other Kubernetes config, a AzureFirewallRules needs apiVersion , Kind , and metadata fields. metadata field includes the name of the policy and the set of labels to identify the resources in Kubernetes. spec : Egressrules spec has all the information needed to define rules on Azure Firewall. egressRules : egressRules field allows us to define list of egress rules on the nodes using the labels asigned to them. This field will allow us to have multiple rules on different node selectors. The example shown above defines two egressRules test-egress-rule-1 and test-egress-rule-2 . And the rules defined in test-egress-rule-1 will be applied to nodes that match label \"app=nginx0\" and the rules in `test-egress-rule-2 will be applied to nodes with label \"nodepool1=set1\" and \"nodepool2=set1\". nodeSelector : nodeSelector is a list of node labels to which the rules should apply. In the above example, we defined the nodeSelector with the label \"app=nginx0\" All the nodes that are grouped using this nodeSelector label will adhere to those rules. rules : rules field allows us define list of azure firewall rules that the nodes grouped using this nodeSelector label should follow. - ruleName , ruleCollectionName , priority , protocol , action , ruleType are the mandatory fields in rules section. - Two rule types are supported in the AzureFirewallRules - Application and Network . Field Description ruleName Name of the rule ruleCollectionName Rule Collection to which the rule should belong. priority The priority value of the rule collection, determines order the rule collections are processed. action Rule Collection action. Applies to all the rules in the rule collection. Supported Values: \"Allow\" or \"Deny\" ruleType Supported rule types: \"Application\" or \"Network\" protocol Defines the protocol that should be used to filter the traffic. Examples: Application rule: [\"https:80\",\"http:443\"] Network rule: [\"TCP\"], [\"TCP\",\"UDP\"], [\"ICMP\"], [\"ANY\"] targetFqdns targetUrls Supported destination types for a Application rule. Specifies the list of destination fqdns or urls that should be used to filter the traffic. destinationAddresses destinationFqdns Supported destination types for a Network rule. Specifies the list of destination addresses or fqdns that should be used to filter the trafficrule. destinationPorts List of destination ports that should be used to filter the traffic in a network rule. Examples of Application Rule Type: The following example allows the egress traffic from nodes with label \"app=service\" to *.google.com. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"Allow-google\" nodeSelector: - app: \"service\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-allow\" priority: 210 targetFqdns: [ \"*.google.com\" ] protocol : [ \"HTTP:80\" ] action : \"Allow\" ruleType: \"Application\" Examples of Network Rule Type: 1. The following example allows egress traffic from nodes with label \"role=db\" to destination addresses \"10.0.0.1\" and \"10.0.0.2\" on any port using TCP. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"Allow-addresses\" nodeSelector: - role: \"db\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network\" priority: 110 destinationAddresses: [ \"10.0.0.1\" , \"10.0.0.2\" ] destinationPorts: [ \"*\" ] protocol : [ \"TCP\" ] action : \"Allow\" ruleType: \"Network\" We can have rules to allow/deny traffic to any destination. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"Allow-web\" nodeSelector: - app: \"service\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network\" priority: 110 destinationAddresses: [ \"*\" ] destinationPorts: [ \"80\" , \"443\" ] protocol : [ \"TCP\" ] action : \"Allow\" ruleType: \"Network\" We can have combination of network and application rules in just one resource. apiVersion: egress.azure-firewall-egress-controller.io/v1 kind: AzureFirewallRules metadata: name: egressrules-sample1 spec: egressRules: - name: \"comb-network-application-rules\" nodeSelector: - app: \"nginx0\" rules: - ruleName: \"rule1\" ruleCollectionName: \"aks-fw-ng-network-deny\" priority: 100 destinationFqdns: [ \"*\" ] destinationPorts: [ \"*\" ] protocol : [ \"TCP\" , \"UDP\" ] action : \"Deny\" ruleType: \"Network\" - ruleName: \"rule2\" ruleCollectionName: \"aks-fw-ng\" priority: 200 targetFqdns: [ \"*.yahoo.com\" ] protocol : [ \"HTTP:80\" ] action : \"Deny\" ruleType: \"Application\"","title":"An example AzureFirewallRules might look like this:"},{"location":"developers/developer-guideline/","text":"","title":"Developer guideline"}]}